<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>ntt (zprize.ntt)</title><link rel="stylesheet" href="../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> â€“ <a href="index.html">zprize</a> &#x00BB; ntt</nav><header class="odoc-preamble"><h2 id="hardcaml_ntt"><a href="#hardcaml_ntt" class="anchor"></a>Hardcaml_ntt</h2><p><a href="Hardcaml_ntt/index.html">Documentation</a></p></header><nav class="odoc-toc"><ul><li><a href="#core-architecture">Core architecture</a><ul><li><a href="#data-path">Data path</a></li><li><a href="#controller">Controller</a></li><li><a href="#rams">RAMs</a><ul><li><a href="#scaling">Scaling</a></li></ul></li></ul></li></ul></nav><div class="odoc-content"><h3 id="core-architecture"><a href="#core-architecture" class="anchor"></a>Core architecture</h3><h4 id="data-path"><a href="#data-path" class="anchor"></a>Data path</h4><p>The data path consists of 2 field multipliers and adders.</p><p>The multipliers are used in the transform phase to process one full butterfly operation per cycle. This consists of scaling the input coefficient and also the root of unity. Thus the performance of this architecture is <code>N/2 * log N</code>.</p><p>The data path is reused to perform the twiddle phase after the first pass of the 4-step algorithm. Each coefficient must be scaled by a specific root of unity and then the root scaled. This pass take N cycles.</p><h4 id="controller"><a href="#controller" class="anchor"></a>Controller</h4><p>The controller sequences the address for coefficient RAMs and the controls the data path.</p><h4 id="rams"><a href="#rams" class="anchor"></a>RAMs</h4><p>We required 2 read and 2 write ports for all RAMs ihn the design. This includes the inputs RAMs, internal RAMs, and output RAMs.</p><p>Since FPGA RAMs consist of 2 ports, we build our require structure from 2 UltraRAMs. Each UltraRAM has both it's ports connected to either the read or write side.</p><p>When a <code>flip</code> signal is toggled the port directions swap.</p><p>The RAMs are architectued such that we can load new INNT coefficents, store a processed INTT, and perform a INNT in parallel.</p><h5 id="scaling"><a href="#scaling" class="anchor"></a>Scaling</h5><p>The <code>Parallel_cores</code> block instantiates <code>1 lsl logcores</code> INTT blocks. It also defines the width of the data path into the cores.</p><p>The <code>Multi_parallel_cores</code> block instantiates <code>1 lsl logblocks</code> <code>Parallel_cores.
This the design scales with [1 lsl (logcores+logblocks)] cores.
</code></p></div></body></html>